<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TransFlow: User guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TransFlow
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A transient pipeline flow simulation library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('user_guide.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">User guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md6">Typical usage</a></li>
<li class="level1"><a href="#autotoc_md7">Advanced options</a><ul><li class="level2"><a href="#autotoc_md8">Sampler</a></li>
<li class="level2"><a href="#autotoc_md9">Boundary conditions</a></li>
<li class="level2"><a href="#autotoc_md10">Equation of state</a></li>
<li class="level2"><a href="#autotoc_md11">Heat transfer</a></li>
<li class="level2"><a href="#autotoc_md12">Equation solver</a><ul><li class="level3"><a href="#autotoc_md13">Convergence and relaxation</a></li>
<li class="level3"><a href="#autotoc_md14">Energy equation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="autotoc_md6"></a>
Typical usage</h1>
<p>To set up a simulation of a pipeline, you typically start by creating a <a class="el" href="classPipeline.html">Pipeline</a> instance which describes the pipeline. </p><pre class="fragment">const double length = 10e3; // length
const double N = 10; // number of grid points
Pipeline pipeline(N, length);
pipeline.roughness().fill(1e-6); // roughness in meters
pipeline.ambientTemperature().fill(278); // 278 Kelvin
pipeline.diameter().fill(0.7); // inner diameter of 70 cm
/* pipeline wall, burial depth, burial medium, ambient fluid, etc. */
</pre><p>(See the members of <a class="el" href="classPipeline.html">Pipeline</a> to see which other properties can be set.)</p>
<p>Then you have to initialize the flow, pressure and temperature of the pipeline. This should have some relation to the boundary condiditions that will be used during the simulation step later, or the program will have issues with convergence. </p><pre class="fragment">pipeline.flow().fill(0); // no initial flow
pipeline.pressure().fill(10e6); // 100 bar
pipeline.temperature().fill(280); // 280 Kelvin
</pre><p>You then create a <a class="el" href="structConfig.html" title="The Config struct stores all settings for the different parts of the pipeline simulation.">Config</a> instance, which has different options for the program </p><pre class="fragment">Config config;
config.equationOfState = "GERG04";
config.outputPath = "./results/";
config.samplingInterval = 5*60; // sample every 5 minutes
/*...*/
</pre><p>Before we can simulate we need some boundary conditions </p><pre class="fragment">TimeSeries bc(100, 60); // 100 steps of 60 seconds
bc.inletFlow().fill(100); // 100 kg/s
bc.outletPressure().fill(10e6); // 100 bar
bc.inletTemperature().fill(280); // 280 Kelvin
</pre><p>Finally create a <a class="el" href="classSimulator.html" title="The Simulator class combines Physics and Solver to advance the state of the pipeline in time....">Simulator</a> instance from the <a class="el" href="classPipeline.html">Pipeline</a> and <a class="el" href="structConfig.html" title="The Config struct stores all settings for the different parts of the pipeline simulation.">Config</a>, and perform the simulation </p><pre class="fragment">Simulator simulator(pipeline, config);
simulator.simulate(bc);
</pre><p>The results are then stored to the folder in <a class="el" href="structConfig.html#a6cbbb02003fac1807bd991ee626a4ede">Config::outputPath</a>, and the final state can also be inspected via </p><pre class="fragment">std::cout &lt;&lt; simulator.state().flow() &lt;&lt; std::endl;
std::cout &lt;&lt; simulator.state().pressure() &lt;&lt; std::endl;
std::cout &lt;&lt; simulator.state().temperature() &lt;&lt; std::endl;
/*...*/
</pre><p>See the files located in the <code>examples</code> for working examples of how to set up a simulation.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Advanced options</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Sampler</h2>
<p>Which results to save can be configured via the <a class="el" href="classSampler.html" title="The Sampler class is used to sample selected Pipeline properties during simulations.">Sampler</a> member of <a class="el" href="classSimulator.html" title="The Simulator class combines Physics and Solver to advance the state of the pipeline in time....">Simulator</a>, accessible via <a class="el" href="classSimulator.html#a63c40e410f521ca1597bb8b95f6a65df" title="Get (ref) sampler.">Simulator::sampler()</a>. Flow, pressure, temperature and outlet composition are stored by default.</p>
<p>Add properties via <a class="el" href="classSampler.html#a31db13b1e7e233e2b7a974474d8b20cb" title="Add property to save to file. This automatically determines the label and filename of the property.">Sampler::addPropertyToPrint</a>, which takes in getters member functions of <a class="el" href="classPipeline.html">Pipeline</a>, as follows </p><pre class="fragment">simulator.sampler().addPropertyToPrint(&amp;Pipeline::reynoldsNumber);
simulator.sampler().addPropertyToPrint(&amp;Pipeline::density);
/*...*/
</pre><p>See the documentation of <a class="el" href="classPipeline.html">Pipeline</a> to see which getters/properties are available.</p>
<p>The convenience functions <a class="el" href="classPipeline.html#a6b926138f6a743b812b74ddf1cade53e" title="Get inlet composition.">Pipeline::inletComposition()</a> and <a class="el" href="classPipeline.html#a1cca52aaac561972fd022aab0019bdbd" title="Get outlet composition.">Pipeline::outletComposition()</a> have been defined, and can also be stored as follows </p><pre class="fragment">simulator.sampler().addPropertyToPrint(&amp;Pipeline::inletComposition);
simulator.sampler().addPropertyToPrint(&amp;Pipeline::outletComposition);
</pre><h2><a class="anchor" id="autotoc_md9"></a>
Boundary conditions</h2>
<p>Boundary conditions for simulating the pipeline are stored in <a class="el" href="classTimeSeries.html" title="The TimeSeries class is used to store the boundary conditions for several time steps.">TimeSeries</a> instances. This consists of a series of timestamps, and flow, pressure, temperature and composition at the inlet and outlet of the pipeline at each time stamp, and also information regarding which property is a constraint at the inlet/outlet when solving the governing equations.</p>
<p><a class="el" href="classTimeSeries.html" title="The TimeSeries class is used to store the boundary conditions for several time steps.">TimeSeries</a> can be created in many different ways, but perhaps the most useful one is by loading a CSV-file, via <a class="el" href="classTimeSeries.html#a2363e079cdacd2ae4949b6361afca396" title="Wrapper for TimeSeries(const std::string&amp;, arma::uword, arma::uword, const std::vector&lt;std::string&gt;&amp;)...">TimeSeries::TimeSeries(const std::string&amp;, const std::vector&lt;std::string&gt;&amp;)</a> </p><pre class="fragment">TimeSeries bc("boundaryConditions.csv");
</pre><p>When using this constructor the boundary settings have to be specified, either via an extra argument to the constructor </p><pre class="fragment">TimeSeries bc("boundaryConditions.csv", {"inlet", "outlet", "intlet"});
</pre><p>or via a call to <a class="el" href="classTimeSeries.html#afa897f2f4aafbb714840e40fbdb1b0dd" title="Set boundary settings via vector of string, or brace-init-list like {&quot;inlet&quot;, &quot;outlet&quot;,...">TimeSeries::setBoundarySettings()</a> after construction </p><pre class="fragment">bc.setBoundarySettings({"inlet", "outlet", "intlet"});
</pre><p>Check the documentation of <a class="el" href="classTimeSeries.html#af66c9cfc6b4114c2117108485ae9f406" title="Load boundary conditions from a CSV.">TimeSeries::TimeSeries(const std::string&amp;, arma::uword, arma::uword, const std::vector&lt;std::string&gt;&amp;)</a> to see how the CSV-file should be structured and what units are expected.</p>
<p>Other useful examples is constructing an empty <a class="el" href="classTimeSeries.html" title="The TimeSeries class is used to store the boundary conditions for several time steps.">TimeSeries</a> and setting all properties manually </p><pre class="fragment">// create empty TimeSeries
const int N = 100; // number of steps
const double dt = 60; // 60 seconds
TimeSeries bc(N, 60);

// set properties
bc.inletFlow() = arma::linspace(0, 100, N); // overloaded copy-assignment operator
bc.outletPressure().fill(10e6);
bc.inletTemperature().fill(280);
</pre><p>When we use this method the properties that are set via fill() or assignment are automatically marked to be used as boundary conditions. For example, after calling </p><pre class="fragment">bc.inletFlow().fill(100);
</pre><p><code>bc.inletFlow().isActive()</code> will return <code>true</code>, and the inlet flow will be used as a boundary condition when solving the governing equations.</p>
<p>The composition is stored as <code>std::vector&lt;<a class="el" href="classComposition.html" title="The Composition class is a simple container class for the composition of natural gas....">Composition</a>&gt;</code>, so it can be a bit more fiddly to set up, but can be done for example via </p><pre class="fragment">bc.inletComposition() = std::vector&lt;Composition&gt;(N, Composition::defaultComposition);
</pre><h2><a class="anchor" id="autotoc_md10"></a>
Equation of state</h2>
<p>At the moment there are two different equations of state implemented in the application:</p><ul>
<li>The <a href="https://en.wikipedia.org/wiki/Benedict%E2%80%93Webb%E2%80%93Rubin_equation#The_BWRS_equation_of_state">BWRS</a> (Benedict–Webb–Rubin-Starling) equation of state, in the class <a class="el" href="classBWRS.html" title="Implements the Benedict-Webb-Rubin-Starling (BWRS) equation of state.">BWRS</a></li>
<li>The <a href="http://www.gerg.eu/public/uploads/files/publications/technical_monographs/tm15_04.pdf">GERG-2004</a> Wide-Range Equation of State for Natural Gases and Other Mixtures, in the class <a class="el" href="classGERG04.html" title="The GERG04 class implements the GERG 2004 equation of state.">GERG04</a></li>
</ul>
<p>This is selected via <a class="el" href="structConfig.html#aeb184f403cd5eef28858c9c272baf93b" title="Equation of state, either &quot;BWRS&quot;, &quot;GERG04&quot; or &quot;IdealGas&quot;.">Config::equationOfState</a>. </p><pre class="fragment">config.equationOfState = "BWRS";
</pre><p>or </p><pre class="fragment">config.equationOfState = "GERG04";
</pre><h2><a class="anchor" id="autotoc_md11"></a>
Heat transfer</h2>
<p>Four different heat transfer models are implemented:</p><ul>
<li>Unsteady 1d radial heat transfer, in the class <a class="el" href="classUnsteadyHeatTransfer.html" title="Implements 1d radial unsteady heat transfer.">UnsteadyHeatTransfer</a></li>
<li>Steady state heat transfer, in the class <a class="el" href="classSteadyStateHeatTransfer.html" title="Class that implements steady state heat transfer between gas and pipeline surroundings.">SteadyStateHeatTransfer</a></li>
<li>Fixed Q value (steady state), in the class <a class="el" href="classFixedQValue.html" title="Implementation of HeatTransferBase for fixed heat flux.">FixedQValue</a></li>
<li>Fixed U value (steady state), in the class <a class="el" href="classFixedUValue.html" title="Implementation of HeatTransferBase for fixed U-value (total heat transfer coefficient).">FixedUValue</a></li>
</ul>
<p>This is selected via <a class="el" href="structConfig.html#a8d50680ef0f07008b0414a5816cc3f70" title="Type of heat transfer, either &quot;SteadyState&quot;, &quot;Unsteady&quot;, &quot;FixedUValue&quot; or &quot;FixedQValue&quot;.">Config::heatTransfer</a>, for example </p><pre class="fragment">config.equationOfState = "SteadyState";
</pre><p>The properties governing heat transfer can be controlled via the <a class="el" href="classPipeline.html">Pipeline</a> instance passed to the <a class="el" href="classSimulator.html" title="The Simulator class combines Physics and Solver to advance the state of the pipeline in time....">Simulator</a> constructor. This is mainly the inner diameter, the <a class="el" href="classPipeWall.html" title="The PipeWall class is a container class that defines the thickness and Material properties of each la...">PipeWall</a>, burial depth, <a class="el" href="classBurialMedium.html" title="The BurialMedium class is a simple container class that defines the conductivity, density and heat ca...">BurialMedium</a>, and <a class="el" href="classAmbientFluid.html" title="The AmbientFluid class is a simple container class that defines the conductivity, density,...">AmbientFluid</a> members of <a class="el" href="classPipeline.html">Pipeline</a>.</p>
<p>Heat transfer is implemented with one <a class="el" href="classHeatTransferBase.html" title="The HeatTransferBase class is an abstract class, the base class for all heat transfer implementations...">HeatTransferBase</a> instance at each grid point. So in theory it is possible to have different heat transfer models at each grid point. But this is not exposed via any interface at the moment (but should not be difficult to implement).</p>
<p><b>NB:</b> At the moment there are no good ways of controlling the Q-value and U-value of <a class="el" href="classFixedQValue.html" title="Implementation of HeatTransferBase for fixed heat flux.">FixedQValue</a> and <a class="el" href="classFixedUValue.html" title="Implementation of HeatTransferBase for fixed U-value (total heat transfer coefficient).">FixedUValue</a>. When a config is passed to the <a class="el" href="classSimulator.html" title="The Simulator class combines Physics and Solver to advance the state of the pipeline in time....">Simulator</a> constructor, the config is passed on to the <a class="el" href="classPhysics.html#ab504d19830e6aeddfb5761f757385ed4" title="Construct from Config and Pipeline.">Physics::Physics(const Pipeline&amp;, const Config&amp;)</a> constructor, and <a class="el" href="structConfig.html#a8d50680ef0f07008b0414a5816cc3f70" title="Type of heat transfer, either &quot;SteadyState&quot;, &quot;Unsteady&quot;, &quot;FixedUValue&quot; or &quot;FixedQValue&quot;.">Config::heatTransfer</a> is passed on to finally reach HeatTransfer::makeSingle (not documented), which just sets Q and U to zero. It <em>can</em> be set as follows, but the interface is not very user-friendly, and it makes use of mutable member variables, which is kind of an anti-pattern </p><pre class="fragment">dynamic_cast&lt;const FixedQValue&amp;&gt;(sim.physics().heatTransfer().at(0)).setQValue(q);
</pre><p>(<code><a class="el" href="classFixedQValue.html" title="Implementation of HeatTransferBase for fixed heat flux.">FixedQValue</a>&amp;</code> needs to be <code>const</code> as the <code>.physics()</code> getter returns <code>const <a class="el" href="classPhysics.html" title="The Physics class combines EquationOfState and HeatTransfer to calculate the new state of a pipeline ...">Physics</a>&amp;</code>, and that is why mutable members are used &ndash; and it is preferred to not introduce non-const getters for <a class="el" href="classSimulator.html#a57d1a832ff51d7a1f6eebbbdc170e288" title="Physics instance, contains HeatTransfer and EquationOfState.">Simulator::m_physics</a> etc.)</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Equation solver</h2>
<p>The <a class="el" href="classSolver.html" title="The Solver class combines GoverningEquationSolver and BatchTracking to advance the governing equation...">Solver</a> class takes care of solving the governing equations. This has several configuration options, which are documented below.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Convergence and relaxation</h3>
<p>The equation solver uses an iterative approach, which checks for convergence after each iteration. The tolerance used when checking if the system has converged is controlled via <a class="el" href="structConfig.html#a2b1f60d6071ad590e033ce2df5258442" title="The convergence criteria used by Solver.">Config::tolerances</a> </p><pre class="fragment">config.tolerances = {0.001, 0.001, 0.001}; // {flow, pressure, temperature}
</pre><p>The convergence check itself is performed in <a class="el" href="classSolver.html#abc6d1dc8b75f1f6c5a70f0fbe39bec28" title="Check if differences between an old and a new state are within tolerances. This will either compare r...">Solver::differencesWithinTolerance</a>.</p>
<p>The tolerance can be configured as either a <em>relative</em> or an <em>absolute</em> limit, via <a class="el" href="structConfig.html#a0366c6b6d36a59f9b7616157e3acb0aa" title="The tolerance of Solver, either &quot;relative&quot; or &quot;absolute&quot;.">Config::toleranceType</a> as follows </p><pre class="fragment">config.toleranceType = "relative";
</pre><p>or </p><pre class="fragment">config.toleranceType = "absolute";
</pre><p>"relative" is the most commonly used option. The maximum number of iterations that are performed before returning is controlled via <a class="el" href="structConfig.html#aaff09e532c29363eca121b6f0d1e8a9b" title="Max number of iterations to use in Solver::solve.">Config::maxIterations</a> </p><pre class="fragment">config.maxIterations = 200;
</pre><p>Relaxation factors are also implemented to allow for easier convergence. The default values are 1.0 for flow and pressure, and 2/3 for temperature. </p><pre class="fragment">config.relaxationFactors = {1, 1, 2/3.0}; // {flow, pressure, temperature}
</pre><p>There is also an option to force a given number of iterations, skipping the convergence check. This is enabled via </p><pre class="fragment">config.bruteForce = true;
</pre><p>and the number of iterations is controlled via </p><pre class="fragment">config.maxIterations = 10;
</pre><h3><a class="anchor" id="autotoc_md14"></a>
Energy equation</h3>
<p>Two different types of energy equations are implemented; the internal energy form, and the enthalpy form (see <em>Form of energy equation in gas-pipeline simulations</em> (Filip Sund and Tor Ytrehus, 2018) for more info). This can be selected via the <a class="el" href="structConfig.html#afc87e666ac91786ef874d7bef9dc3006" title="Type of energy equation, either &quot;InternalEnergy&quot; or &quot;Enthalpy&quot;.">Config::discretizer</a> parameter. </p><pre class="fragment">std::string discretizer = "InternalEnergy";
</pre><p>or </p><pre class="fragment">std::string discretizer = "Enthalpy";
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
